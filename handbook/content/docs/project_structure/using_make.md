---
title: "GNU make"
weight: 1
desc: "How to use `make` to automate project execution."
---

# Using GNU Make for rebuilding projects
*How to use `make` to automate project execution.*

![Ongoing](https://img.shields.io/badge/status-ongoing-orange)

{{< hint warning >}}
This page is missing best practices on how to write makefiles.
{{< /hint >}}

## Aim
This page is handy when writing or reading `makefile`s for projects.

## Also read
- The Turing Way [guide on makefiles](https://the-turing-way.netlify.app/reproducible-research/make.html).

## What are makefiles

Makefiles are text files read by a program called `make` (or also GNU `make`) that is preinstalled in many distributions. Makefiles hold recipes for generating files. `make` reads these makefiles and generates the outputs following the recipes. The main difference between `make` and a simple shell script is that `make` looks at the timestamps of the generated files and their prerequisites and *only (re)generates the missing or out-of-date files*.

This is tremendously useful when running complex analyses, and brings a whole bunch of benefits:
- The makefile exactly records the steps needed to run the analysis, which is essential for reproducibility.
- Writing makefiles makes you think about the data flow in your analysis, often making you catch bugs even before you write any code.
- People working with you and even yourself can reproduce the analysis on different machines in just one (or a few) commands.
- People reading the publication and reviewers have an easy time remaking your analysis, especially if you add a docker container.

A lot of pages in the handbook are written with `make` automation in mind.

## Alternatives to make
If you just want a single entrypoint for a series of disconnected scripts, you probably want [`just`](https://github.com/casey/just).
It's similar to `make` in spirit, but is much more streamlined for that use-case.

If you feel you need something more structured, you can take a look at [workflow managers](docs/code/workflow_managers.md), like [`nextflow`](https://www.nextflow.io/).

## When you should write makefiles
You should write a makefile and update it very early in the project. It would be best to stop running steps manually (except when debugging) and instead add rules to the makefile and invoke `make` every time.

# Where to put your makefiles
A makefile should live in the root of the repository. If you have many makefiles, you might consider putting all of them in a specific `makefiles/` folder in the root of the project. `make` looks for a file in the current wd called `makefile` or `Makefile` by default. See [this StackOverflow question](https://stackoverflow.com/questions/28054448/specifying-path-to-makefile-using-make-command) for critical things to keep in mind if you want to run make not from the root of the repository.

You can include multiple makefiles in the same file with [the `include` keyword](https://www.gnu.org/software/make/manual/html_node/Include.html).

## What your makefile should make
In theory, it should run every step of your analysis: from data retrieval to the generation of the output author manuscript. However, this might be difficult or even impossible in some cases, so try to have `make` cover as much of the process as possible, and carefully **document the rest**.

## How to write makefiles

The GNU `make` manual is the bible of `make`. [Read it here](https://www.gnu.org/software/make/manual/make.html). There is no need to repeat the whole manual or even a large portion of it here. However, a refresher could be useful:

- A makefile is made up of *rules* (or *targets*). Each rule may have one or more *requirements*. Every rule has a target: either a file that (in principle) will be generated by the execution of the rule, or not. Rules that do not make files are called *phony*. Phony rules are useful when you want to group together other rules: for example, most makefiles contain an `all` rule that, when called, calls every other rule. Another common phony rule that you can write is `clean`, which removes all files generated by the other rules.
- Every phony rule must be declared as such in the `.PHONY` special variable (e.g. `.PHONY = all clean`)
- The series of commands that are run to make a target make up the *body* of the rule. The body of the rule **must** be indented *with a **tab*** (`\t`).
- `make` may execute rules in parallel (for those that could run in parallel). Additionally, *each row in a rule body is run in a new shell*. This has some repercussions: it allows make to be more efficient, but also does not allow for, say, a `cd` command to apply to the whole rule body. Use `;` to bind together commands that must be run in the same shell.
- You can add comments outside of a function's body with the standard `#`. But `make` will pass on to the shell any `#`s it finds in rule bodies, so it's up to the shell to treat it as a comment or not. For this reason, it's not recommended to write comments in the body of a rule.

# Useful extracts from the manual
Some ideas from the GNU `make` manual are useful to have handy:

## Automatic variables
GNU `make` will set *automatic* variables at runtime for every rule. See [the official documentation][https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html]. If this is the rule, the above are some of the most used automatic variables:
```
|------------ $@ ---------------|
|-- $(@D) ---| |----- $(@F) ----|   |-------- $< -------|
some\path\to\a\very_cool_file.txt : some_prerequisite.csv
```

- Note that `$@` is equal to `$(@D)` + `\` + `$(@F)`.
- `$(@D)` is especially useful to run `mkdir -p $(@D)` (making the output folder for the file);

## Conditionals
You can write if/else if/else statements in makefiles, to control if some part of the makefile is evaluated or not. An example:

```makefile
conditional_file: some_prereq.py
    ifeq $(py_ver) '3.11'
    python3.11 some_prereq.py
    else ifeq $(p_ver) '3.10'
    python3.10 some_prereq.py
    endif
```

The relevant part of the `make` manual [can be found here](https://www.gnu.org/software/make/manual/html_node/Conditionals.html).

## Functions
`make` provides functions to mainly manipulate the names of targets so that writing makefiles is more ergonomic. Functions look like variable calls, of the form `$(fun_name ARG,ARG,ARG)`. Almost all functions can be used on lists of space-separated values.

You can find all the functions in the manual in the [text functions](https://www.gnu.org/software/make/manual/html_node/Functions.html) chapter. To have links to them handy, however, I list them here:
- [`subst`](https://www.gnu.org/software/make/manual/html_node/Text-Functions.html#index-subst-1): Replace text with something else:
- [`patsubst`](https://www.gnu.org/software/make/manual/html_node/Text-Functions.html#index-patsubst-1): Replace a *pattern* in text with something else:
- [`strip`](https://www.gnu.org/software/make/manual/html_node/Text-Functions.html#index-stripping-whitespace): Remove trailing, leading and interspersed whitespace:
- [`findstring`](https://www.gnu.org/software/make/manual/html_node/Text-Functions.html#index-findstring): Find a pattern in a string, returning the pattern (if found) or an empty string. This is very useful for conditionals:
- [`filter`](https://www.gnu.org/software/make/manual/html_node/Text-Functions.html#index-filter) and [`filter-out`](https://www.gnu.org/software/make/manual/html_node/Text-Functions.html#index-filter_002dout): Keep words that match or do not match a pattern:
- [`sort`](https://www.gnu.org/software/make/manual/html_node/Text-Functions.html#index-sort): Sort **and remove duplicated** words from the input:
- [`word`](https://www.gnu.org/software/make/manual/html_node/Text-Functions.html#index-word): Grab the `n`-th word from a list of words.
- [`wordlist`](https://www.gnu.org/software/make/manual/html_node/Text-Functions.html#index-wordlist): Grab a slice of a list of words starting from some word and ending with some other.
- [`words`](https://www.gnu.org/software/make/manual/html_node/Text-Functions.html#index-words): Count the number of words in a list.
- [`firstword`](https://www.gnu.org/software/make/manual/html_node/Text-Functions.html#index-firstword) and [`lastword`](https://www.gnu.org/software/make/manual/html_node/Text-Functions.html#index-lastword): Return the first and last words in the list. Superseded by `word`, but retained for simplicity.
- [`dir`](https://www.gnu.org/software/make/manual/html_node/File-Name-Functions.html#index-dir) and [`notdir`](https://www.gnu.org/software/make/manual/html_node/File-Name-Functions.html#index-notdir): Extract the directory part or all but the directory part from a UNIX path. Care that `$(notdir some_dir/with_ending/backslash/)` will evaluate to `''`.
- [`suffix`](https://www.gnu.org/software/make/manual/html_node/File-Name-Functions.html#index-suffix) and [`basename`](https://www.gnu.org/software/make/manual/html_node/File-Name-Functions.html#index-basename-1): return the suffix or everything but the suffix (including parent directories) of the input words.
- [`addsuffix`](https://www.gnu.org/software/make/manual/html_node/File-Name-Functions.html#index-addsuffix) and [`addprefix`](https://www.gnu.org/software/make/manual/html_node/File-Name-Functions.html#index-addprefix): Add a string after or before every input.
- [`join`](https://www.gnu.org/software/make/manual/html_node/File-Name-Functions.html#index-join): Join word-by-word two lists of words. Check the documentation.
- [`wildcard`](https://www.gnu.org/software/make/manual/html_node/File-Name-Functions.html#index-wildcard-2), [`realpath`](https://www.gnu.org/software/make/manual/html_node/File-Name-Functions.html#index-realpath-1) and [`abspath`](https://www.gnu.org/software/make/manual/html_node/File-Name-Functions.html#index-abspath-1): Find matching files, return to real paths (like the `realpath` shell command) or just resolve relative path links. 

There are also functions tha expand to `if` statements, or resolve `or` and `and` conditionals. See the [chapter on conditional functions](https://www.gnu.org/software/make/manual/html_node/Conditional-Functions.html) for the `if`, `and`, `or` and `intcmp` functions.

Other, special functions are:
- [`let`](https://www.gnu.org/software/make/manual/html_node/Let-Function.html): To limit the scope of a variable to a local context;
- [`foreach`](https://www.gnu.org/software/make/manual/html_node/Foreach-Function.html): To implement a `for` loop;
- [`file`](https://www.gnu.org/software/make/manual/html_node/File-Function.html): To read to and from a file;
- [`call`](https://www.gnu.org/software/make/manual/html_node/Call-Function.html): To define new functions;
- [`value`](https://www.gnu.org/software/make/manual/html_node/Value-Function.html): To safely use variables contained in other variables;
- [`eval`](https://www.gnu.org/software/make/manual/html_node/Eval-Function.html): Evaluate a portion of a makefile, or the content of a variable, or the output from other functions as makefile lines. This allows to programmatically write makefiles from variables.
- [`origin`](https://www.gnu.org/software/make/manual/html_node/Origin-Function.html) and [`flavor`](https://www.gnu.org/software/make/manual/html_node/Flavor-Function.html): Inspect the origin of a variable and its flavor (recursively expanded or not).

The `error`, `warning` and `info` functions can be used to send out warning and info messages or terminate make with an error early. [Read the manual page](https://www.gnu.org/software/make/manual/html_node/Make-Control-Functions.html).

The [`shell`](https://www.gnu.org/software/make/manual/html_node/Shell-Function.html) function can be used to evaluate a command in the shell and use its output as makefile lines.

# Pro tips

## Splitting long lines
Long lines can be split by adding a single `/` just before the end of the line. `make` will consider that line to logically continue to the next line, removing all whitespace before the first word on the next line (and replacing it with just one space). This:
```makefile
some_target : first_prereq /
        second_prereq /
        third_prereq
    @echo "First recipe line"
    @echo "Second recipe line" ; /
    @echo "Still the second line!"
```
Is identical to:
```makefile
some_target: first_prereq second_prereq third_prereq
    @echo "First recipe line"
    @echo "Second recipe line" ; echo "Still the second line!"
```

## Handling variable numbers of generated files
If one of your rules generates a variable number of files, do not try to configure `make` in some magical way to have one rule per output files. Instead, group the files into a target directory, and use as an actual target for your rule a *flag* file. These files are empty, made by `touch`, and are just there as a timestamp to let `make` know when was the last time that it (re)generated the series of output files.

A caveat of this is that `make` will not notice updates to the series of files in the folder. However, this scenario occurs most often when generating intermediate data files, so editing them directly should not be needed (or could even be a symptom of something going wrong).

Remember that you can force `make` to reconstruct the files even when (it thinks that) it is not needed with the `-B` or `--always-make` flag.

Example: The `make_variables.py` script makes a variable number of files in some output directory. We don't know how many it will make, but we can keep track of its execution with a flag file:
```makefile
/some/path/made_variables.flag: make_variables.py
    python make_variables.py
    mkdir -p $(@D)
    touch $@
```
The flag file needs not end up with `.flag`, but it helps to clarify its role.

If you need to read these files in another rule, use the `.flag` file as requirement and `find` or walk over the other files in the directory.

## Using make and docker together
Docker is the perfect complement to make. Docker ships the environment and make provides the execution. Keep these in mind when using docker and make:
- [Read the handbook on tips for docker containers](docs/miscellaneous/containerizing.md).
- Use `CMD make .` at the end of the dockerfile to run make when the container is executed.
- To use Python virtual environments, make a rule that generates the virtual environment, and then source it at every rule that needs it. Remember to bind commands with `;`, since every line in a rule body is run in a new shell:

    ```makefile
    .PHONY = env

    # make a phony env target if you just want to remake the env. 
    env: env/touchfile

    # The dot operator is the same as source, but it is the POSIX standard
    env/touchfile: requirements.txt
        python -m venv env
        . env/bin/activate; pip install -Ur requirements.txt
        touch env/touchfile

    rule/that/uses/python.txt: script.py
        . env/bin/activate; python script.py
    ```

- Remember to bind the appropriate input/output folders when executing the docker so that `make` saves the files on the disk.

## Using flexible PHONY and ALL targets
To declare phony targets, you have to list them in `PHONY`. But you may have all of them scattered throughout your file, and you might add or remove them frequently.
To avoid updating the same line over an over again, you can create a variable (e.g. `PHONY`, without the dot), and append your phony targets to it. At the end of the makefile, you can just do `.PHONY = $(PHONY)`:
```makefile

PHONY += clean
clean:
    rm -rf ./data

PHONY += all
all: ./data/my_file
    touch $@

.PHONY = $(PHONY)
```

Similarly, you can do the same with `all` to specify an easily modifiable list of default targets:
```makefile

ALL += file_one
file_one:
    touch $@

ALL += file_two
file_two:
    touch $@

all: $(ALL)

# You have to set `all` to be PHONY
.PHONY = all

# Since all is defined at the bottom, we need to make it default:
.DEFAULT_GOAL = all
```

Read [the manual for `.DEFAULT_GOAL`](https://www.gnu.org/software/make/manual/html_node/How-Make-Works.html), [the page for growing variables with `+=`](https://www.gnu.org/software/make/manual/html_node/Appending.html).
