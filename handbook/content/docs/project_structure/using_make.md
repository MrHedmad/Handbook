---
title: "GNU make"
weight: 1
desc: "How to use `make` to automate project execution."
---

# Using GNU Make for rebuilding projects
*How to use `make` to automate project execution.*

![Ongoing](https://img.shields.io/badge/status-ongoing-orange)

{{< hint warning >}}
This page is missing best practices on how to write makefiles.
{{< /hint >}}

## Aim
This page is handy when writing or reading `makefile`s for projects.

## What are makefiles

Makefiles are text files read by a program called `make` (or also GNU `make`) that is preinstalled in many distributions. Makefiles hold recipes for generating files. `make` read these recipes and generates the files based on the recipe. The main difference in respect of a simple shell script that does the same is that `make` looks at the timestamps of the generated files and their prerequisites and *only (re)generates the missing or out-of-date files*.

This is tremendously useful when running complex analyses:
- The makefile exactly records the steps needed to run the analysis, which is essential for reproducibility.
- Writing makefiles makes you think about the data flow in your analysis, often making you catch bugs even before you write any code.
- People working with you and even yourself can reproduce the analysis on different machines in just one (or a few) commands.
- People reading the publication and reviewers have an easy time remaking your analysis, especially if you add a docker container.

## When you should write makefiles

You should write a makefile and update it very early in the project. It would be best to stop running steps manually (except when debugging) and instead add rules to the makefile and invoke `make` every time.

# Where to put your makefiles
A makefile should live in the root of the repository. If you have many makefiles, you might consider putting all of them in a specific `makefiles/` folder in the root of the project. `make` looks for a file in the current wd called `makefile` or `Makefile` by default. See [this StackOverflow question](https://stackoverflow.com/questions/28054448/specifying-path-to-makefile-using-make-command) for critical things to keep in mind if you want to run make not from the root of the repository.

## What your makefile should make

In theory, it should run every step of your analysis: from data retrieval to the generation of the output author manuscript. However, this might be difficult or even impossible in some cases, so try to have `make` cover as much of the process as possible, and carefully **document the rest**.

## How to write makefiles

The GNU `make` manual is the bible of `make`. [Read it here](https://www.gnu.org/software/make/manual/make.html). As a crash course:

- A makefile is made up of *rules* (or *targets*). Each rule may have one or more *requirements*. Every rule has a target: either a file that (in principle) will be generated by the execution of the rule, or not. Rules that do not make files are called *phony*. Phony rules are useful when you want to group together other rules: for example, most makefiles contain an `all` rule that, when called, calls every other rule. Another common phony rule is `clean`, which removes all files generated by the other rules.
- Every phony rule must be declared as such in the `.PHONY` special variable (e.g. `.PHONY = all clean`)
- The series of commands that are run to make a target make up the *body* of the rule. The body of the rule **must** be indented *with a **tab*** (`\t`).
- `make` optimizes at runtime and may execute rules in parallel. Additionally, *each row in a rule body is run in a new shell*. This has some repercussions: it allows make to be more efficient, but also does not allow for, say, a `cd` command to apply to the whole rule body. Use `;` to bind together commands that must be run in the same shell.
- You can add comments outside of a function's body with the standard `#`. But `make` will pass on to the shell any `#`s it finds in rule bodies, so it's up to the shell to treat it as a comment or not. For this reason, it's not recommended to write comments in the body of a rule.

# Useful extracts from the manual

## Special variables

GNU `make` will set special variables at runtime for every rule. See [the official documentation][https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html]. A very quick primer:
```
|------------ $@ ---------------|
|-- $(@D) ---| |----- $(@F) ----|   |-------- $< -------|
some\path\to\a\very_cool_file.txt : some_prerequisite.csv
```

- Note that `$@` is equal to `$(@D)` + `\` + `$(@F)`.
- `$(@D)` is especially useful to run `mkdir -p $(@D)` (making the output folder for the file);

# Pro tips

## Handling variable numbers of generated files
If one of your rules generates a variable number of files, do not try to configure `make` in some magical way to have one rule per output files. Instead, group the files into a target directory, and use as an actual target for your rule a *flag* file. These files are empty, made by `touch`, and are just there as a timestamp to let `make` know when was the last time that it (re)generated the series of output files.

A caveat of this is that `make` will not notice updates to the series of files in the folder. However, this scenario occurs most often when generating intermediate data files, so editing them directly should not be needed.

Remember that you can force `make` to reconstruct the files even when it (thinks that) it is not needed with the `-B` or `--always-make` flag.

Example: The `make_variables.py` script makes a variable number of files in some output directory. We don't know how many it will make, but we can keep track of its execution with a flag file:
```makefile
/some/path/made_variables.flag: make_variables.py
    python make_variables.py
    mkdir -p $(@D)
    touch $@
```
The flag file needs not end up with `.flag`, but it helps to clarify its role.
]
## Using make and docker together
Docker is the perfect complement to make. Docker ships the environment and make provides the execution. Keep these in mind when using docker and make:
- [Read the handbook on tips for docker containers](docs/miscellaneous/containerizing.md).
- Use `CMD make .` at the end of the dockerfile to run make when the container is executed.
- To use Python virtual environments, make a rule that generates the virtual environment, and then source it at every rule that needs it. Remember to use bind commands with `;`, since every line in a rule body is run in a new shell:

    <!-- language: makefile -->

        .PHONY = env

        # make a phony env target if you just want to remake the env. 
        env: env/touchfile

        # The dot operator is the same as source, but it is the POSIX standard
        env/touchfile: requirements.txt
            python -m venv env
            . env/bin/activate; pip install -Ur requirements.txt
            touch env/touchfile
        
        rule/that/uses/python.txt: script.py
            . env/bin/activate; python script.py
